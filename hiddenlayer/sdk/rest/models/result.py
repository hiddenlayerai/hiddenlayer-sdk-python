# coding: utf-8

"""
    HiddenLayer ModelScan V2

    HiddenLayer ModelScan API for scanning of models

    The version of the OpenAPI document: 1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from hiddenlayer.sdk.rest.models.artifact_location import ArtifactLocation
from hiddenlayer.sdk.rest.models.attachment import Attachment
from hiddenlayer.sdk.rest.models.code_flow import CodeFlow
from hiddenlayer.sdk.rest.models.fix import Fix
from hiddenlayer.sdk.rest.models.graph import Graph
from hiddenlayer.sdk.rest.models.graph_traversal import GraphTraversal
from hiddenlayer.sdk.rest.models.location import Location
from hiddenlayer.sdk.rest.models.message import Message
from hiddenlayer.sdk.rest.models.property_bag import PropertyBag
from hiddenlayer.sdk.rest.models.reporting_descriptor_reference import ReportingDescriptorReference
from hiddenlayer.sdk.rest.models.result_provenance import ResultProvenance
from hiddenlayer.sdk.rest.models.stack import Stack
from hiddenlayer.sdk.rest.models.suppression import Suppression
from hiddenlayer.sdk.rest.models.web_request import WebRequest
from hiddenlayer.sdk.rest.models.web_response import WebResponse
from typing import Optional, Set
from typing_extensions import Self

class Result(BaseModel):
    """
    A result produced by an analysis tool.
    """ # noqa: E501
    rule_id: Optional[StrictStr] = Field(default=None, description="The stable, unique identifier of the rule, if any, to which this result is relevant.", alias="ruleId")
    rule_index: Optional[Annotated[int, Field(strict=True, ge=-1)]] = Field(default=-1, description="The index within the tool component rules array of the rule object associated with this result.", alias="ruleIndex")
    rule: Optional[ReportingDescriptorReference] = None
    kind: Optional[StrictStr] = Field(default='fail', description="A value that categorizes results by evaluation state.")
    level: Optional[StrictStr] = Field(default='warning', description="A value specifying the severity level of the result.")
    message: Optional[Message]
    analysis_target: Optional[ArtifactLocation] = Field(default=None, alias="analysisTarget")
    locations: Optional[Annotated[List[Location], Field(min_length=0)]] = Field(default=None, description="The set of locations where the result was detected. Specify only one location unless the problem indicated by the result can only be corrected by making a change at every specified location.")
    guid: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="A stable, unique identifier for the result in the form of a GUID.")
    correlation_guid: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="A stable, unique identifier for the equivalence class of logically identical results to which this result belongs, in the form of a GUID.", alias="correlationGuid")
    occurrence_count: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=None, description="A positive integer specifying the number of times this logically unique result was observed in this run.", alias="occurrenceCount")
    partial_fingerprints: Optional[Dict[str, StrictStr]] = Field(default=None, description="A set of strings that contribute to the stable, unique identity of the result.", alias="partialFingerprints")
    fingerprints: Optional[Dict[str, StrictStr]] = Field(default=None, description="A set of strings each of which individually defines a stable, unique identity for the result.")
    stacks: Optional[Annotated[List[Stack], Field(min_length=0)]] = Field(default=None, description="An array of 'stack' objects relevant to the result.")
    code_flows: Optional[Annotated[List[CodeFlow], Field(min_length=0)]] = Field(default=None, description="An array of 'codeFlow' objects relevant to the result.", alias="codeFlows")
    graphs: Optional[Annotated[List[Graph], Field(min_length=0)]] = Field(default=None, description="An array of zero or more unique graph objects associated with the result.")
    graph_traversals: Optional[Annotated[List[Optional[GraphTraversal]], Field(min_length=0)]] = Field(default=None, description="An array of one or more unique 'graphTraversal' objects.", alias="graphTraversals")
    related_locations: Optional[Annotated[List[Location], Field(min_length=0)]] = Field(default=None, description="A set of locations relevant to this result.", alias="relatedLocations")
    suppressions: Optional[Annotated[List[Suppression], Field(min_length=0)]] = Field(default=None, description="A set of suppressions relevant to this result.")
    baseline_state: Optional[StrictStr] = Field(default=None, description="The state of a result relative to a baseline of a previous run.", alias="baselineState")
    rank: Optional[Union[Annotated[float, Field(le=100, strict=True, ge=-1)], Annotated[int, Field(le=100, strict=True, ge=-1)]]] = Field(default=-1, description="A number representing the priority or importance of the result.")
    attachments: Optional[Annotated[List[Attachment], Field(min_length=0)]] = Field(default=None, description="A set of artifacts relevant to the result.")
    hosted_viewer_uri: Optional[StrictStr] = Field(default=None, description="An absolute URI at which the result can be viewed.", alias="hostedViewerUri")
    work_item_uris: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="The URIs of the work items associated with this result.", alias="workItemUris")
    provenance: Optional[ResultProvenance] = None
    fixes: Optional[Annotated[List[Fix], Field(min_length=0)]] = Field(default=None, description="An array of 'fix' objects, each of which represents a proposed fix to the problem indicated by the result.")
    taxa: Optional[Annotated[List[Optional[ReportingDescriptorReference]], Field(min_length=0)]] = Field(default=None, description="An array of references to taxonomy reporting descriptors that are applicable to the result.")
    web_request: Optional[WebRequest] = Field(default=None, alias="webRequest")
    web_response: Optional[WebResponse] = Field(default=None, alias="webResponse")
    properties: Optional[PropertyBag] = None
    __properties: ClassVar[List[str]] = ["ruleId", "ruleIndex", "rule", "kind", "level", "message", "analysisTarget", "locations", "guid", "correlationGuid", "occurrenceCount", "partialFingerprints", "fingerprints", "stacks", "codeFlows", "graphs", "graphTraversals", "relatedLocations", "suppressions", "baselineState", "rank", "attachments", "hostedViewerUri", "workItemUris", "provenance", "fixes", "taxa", "webRequest", "webResponse", "properties"]

    @field_validator('kind')
    def kind_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['notApplicable', 'pass', 'fail', 'review', 'open', 'informational']):
            raise ValueError("must be one of enum values ('notApplicable', 'pass', 'fail', 'review', 'open', 'informational')")
        return value

    @field_validator('level')
    def level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['none', 'note', 'warning', 'error']):
            raise ValueError("must be one of enum values ('none', 'note', 'warning', 'error')")
        return value

    @field_validator('guid')
    def guid_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$", value):
            raise ValueError(r"must validate the regular expression /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/")
        return value

    @field_validator('correlation_guid')
    def correlation_guid_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$", value):
            raise ValueError(r"must validate the regular expression /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/")
        return value

    @field_validator('baseline_state')
    def baseline_state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['new', 'unchanged', 'updated', 'absent']):
            raise ValueError("must be one of enum values ('new', 'unchanged', 'updated', 'absent')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Result from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of rule
        if self.rule:
            _dict['rule'] = self.rule.to_dict()
        # override the default output from pydantic by calling `to_dict()` of message
        if self.message:
            _dict['message'] = self.message.to_dict()
        # override the default output from pydantic by calling `to_dict()` of analysis_target
        if self.analysis_target:
            _dict['analysisTarget'] = self.analysis_target.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in locations (list)
        _items = []
        if self.locations:
            for _item in self.locations:
                if _item:
                    _items.append(_item.to_dict())
            _dict['locations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in stacks (list)
        _items = []
        if self.stacks:
            for _item in self.stacks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['stacks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in code_flows (list)
        _items = []
        if self.code_flows:
            for _item in self.code_flows:
                if _item:
                    _items.append(_item.to_dict())
            _dict['codeFlows'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in graphs (list)
        _items = []
        if self.graphs:
            for _item in self.graphs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['graphs'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in graph_traversals (list)
        _items = []
        if self.graph_traversals:
            for _item in self.graph_traversals:
                if _item:
                    _items.append(_item.to_dict())
            _dict['graphTraversals'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in related_locations (list)
        _items = []
        if self.related_locations:
            for _item in self.related_locations:
                if _item:
                    _items.append(_item.to_dict())
            _dict['relatedLocations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in suppressions (list)
        _items = []
        if self.suppressions:
            for _item in self.suppressions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['suppressions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in attachments (list)
        _items = []
        if self.attachments:
            for _item in self.attachments:
                if _item:
                    _items.append(_item.to_dict())
            _dict['attachments'] = _items
        # override the default output from pydantic by calling `to_dict()` of provenance
        if self.provenance:
            _dict['provenance'] = self.provenance.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in fixes (list)
        _items = []
        if self.fixes:
            for _item in self.fixes:
                if _item:
                    _items.append(_item.to_dict())
            _dict['fixes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in taxa (list)
        _items = []
        if self.taxa:
            for _item in self.taxa:
                if _item:
                    _items.append(_item.to_dict())
            _dict['taxa'] = _items
        # override the default output from pydantic by calling `to_dict()` of web_request
        if self.web_request:
            _dict['webRequest'] = self.web_request.to_dict()
        # override the default output from pydantic by calling `to_dict()` of web_response
        if self.web_response:
            _dict['webResponse'] = self.web_response.to_dict()
        # override the default output from pydantic by calling `to_dict()` of properties
        if self.properties:
            _dict['properties'] = self.properties.to_dict()
        # set to None if rule (nullable) is None
        # and model_fields_set contains the field
        if self.rule is None and "rule" in self.model_fields_set:
            _dict['rule'] = None

        # set to None if message (nullable) is None
        # and model_fields_set contains the field
        if self.message is None and "message" in self.model_fields_set:
            _dict['message'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Result from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ruleId": obj.get("ruleId"),
            "ruleIndex": obj.get("ruleIndex") if obj.get("ruleIndex") is not None else -1,
            "rule": ReportingDescriptorReference.from_dict(obj["rule"]) if obj.get("rule") is not None else None,
            "kind": obj.get("kind") if obj.get("kind") is not None else 'fail',
            "level": obj.get("level") if obj.get("level") is not None else 'warning',
            "message": Message.from_dict(obj["message"]) if obj.get("message") is not None else None,
            "analysisTarget": ArtifactLocation.from_dict(obj["analysisTarget"]) if obj.get("analysisTarget") is not None else None,
            "locations": [Location.from_dict(_item) for _item in obj["locations"]] if obj.get("locations") is not None else None,
            "guid": obj.get("guid"),
            "correlationGuid": obj.get("correlationGuid"),
            "occurrenceCount": obj.get("occurrenceCount"),
            "partialFingerprints": obj.get("partialFingerprints"),
            "fingerprints": obj.get("fingerprints"),
            "stacks": [Stack.from_dict(_item) for _item in obj["stacks"]] if obj.get("stacks") is not None else None,
            "codeFlows": [CodeFlow.from_dict(_item) for _item in obj["codeFlows"]] if obj.get("codeFlows") is not None else None,
            "graphs": [Graph.from_dict(_item) for _item in obj["graphs"]] if obj.get("graphs") is not None else None,
            "graphTraversals": [GraphTraversal.from_dict(_item) for _item in obj["graphTraversals"]] if obj.get("graphTraversals") is not None else None,
            "relatedLocations": [Location.from_dict(_item) for _item in obj["relatedLocations"]] if obj.get("relatedLocations") is not None else None,
            "suppressions": [Suppression.from_dict(_item) for _item in obj["suppressions"]] if obj.get("suppressions") is not None else None,
            "baselineState": obj.get("baselineState"),
            "rank": obj.get("rank") if obj.get("rank") is not None else -1,
            "attachments": [Attachment.from_dict(_item) for _item in obj["attachments"]] if obj.get("attachments") is not None else None,
            "hostedViewerUri": obj.get("hostedViewerUri"),
            "workItemUris": obj.get("workItemUris"),
            "provenance": ResultProvenance.from_dict(obj["provenance"]) if obj.get("provenance") is not None else None,
            "fixes": [Fix.from_dict(_item) for _item in obj["fixes"]] if obj.get("fixes") is not None else None,
            "taxa": [ReportingDescriptorReference.from_dict(_item) for _item in obj["taxa"]] if obj.get("taxa") is not None else None,
            "webRequest": WebRequest.from_dict(obj["webRequest"]) if obj.get("webRequest") is not None else None,
            "webResponse": WebResponse.from_dict(obj["webResponse"]) if obj.get("webResponse") is not None else None,
            "properties": PropertyBag.from_dict(obj["properties"]) if obj.get("properties") is not None else None
        })
        return _obj



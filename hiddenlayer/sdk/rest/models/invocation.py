# coding: utf-8

"""
    HiddenLayer-API

    HiddenLayer-API

    The version of the OpenAPI document: 1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from hiddenlayer.sdk.rest.models.artifact_location import ArtifactLocation
from hiddenlayer.sdk.rest.models.configuration_override import ConfigurationOverride
from hiddenlayer.sdk.rest.models.notification import Notification
from hiddenlayer.sdk.rest.models.property_bag import PropertyBag
from typing import Optional, Set
from typing_extensions import Self

class Invocation(BaseModel):
    """
    The runtime environment of the analysis tool run.
    """ # noqa: E501
    command_line: Optional[StrictStr] = Field(default=None, description="The command line used to invoke the tool.", alias="commandLine")
    arguments: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="An array of strings, containing in order the command line arguments passed to the tool from the operating system.")
    response_files: Optional[Annotated[List[ArtifactLocation], Field(min_length=0)]] = Field(default=None, description="The locations of any response files specified on the tool's command line.", alias="responseFiles")
    start_time_utc: Optional[datetime] = Field(default=None, description="The Coordinated Universal Time (UTC) date and time at which the invocation started. See \"Date/time properties\" in the SARIF spec for the required format.", alias="startTimeUtc")
    end_time_utc: Optional[datetime] = Field(default=None, description="The Coordinated Universal Time (UTC) date and time at which the invocation ended. See \"Date/time properties\" in the SARIF spec for the required format.", alias="endTimeUtc")
    exit_code: Optional[StrictInt] = Field(default=None, description="The process exit code.", alias="exitCode")
    rule_configuration_overrides: Optional[Annotated[List[ConfigurationOverride], Field(min_length=0)]] = Field(default=None, description="An array of configurationOverride objects that describe rules related runtime overrides.", alias="ruleConfigurationOverrides")
    notification_configuration_overrides: Optional[Annotated[List[ConfigurationOverride], Field(min_length=0)]] = Field(default=None, description="An array of configurationOverride objects that describe notifications related runtime overrides.", alias="notificationConfigurationOverrides")
    tool_execution_notifications: Optional[Annotated[List[Notification], Field(min_length=0)]] = Field(default=None, description="A list of runtime conditions detected by the tool during the analysis.", alias="toolExecutionNotifications")
    tool_configuration_notifications: Optional[Annotated[List[Notification], Field(min_length=0)]] = Field(default=None, description="A list of conditions detected by the tool that are relevant to the tool's configuration.", alias="toolConfigurationNotifications")
    exit_code_description: Optional[StrictStr] = Field(default=None, description="The reason for the process exit.", alias="exitCodeDescription")
    exit_signal_name: Optional[StrictStr] = Field(default=None, description="The name of the signal that caused the process to exit.", alias="exitSignalName")
    exit_signal_number: Optional[StrictInt] = Field(default=None, description="The numeric value of the signal that caused the process to exit.", alias="exitSignalNumber")
    process_start_failure_message: Optional[StrictStr] = Field(default=None, description="The reason given by the operating system that the process failed to start.", alias="processStartFailureMessage")
    execution_successful: StrictBool = Field(description="Specifies whether the tool's execution completed successfully.", alias="executionSuccessful")
    machine: Optional[StrictStr] = Field(default=None, description="The machine on which the invocation occurred.")
    account: Optional[StrictStr] = Field(default=None, description="The account under which the invocation occurred.")
    process_id: Optional[StrictInt] = Field(default=None, description="The id of the process in which the invocation occurred.", alias="processId")
    executable_location: Optional[ArtifactLocation] = Field(default=None, alias="executableLocation")
    working_directory: Optional[ArtifactLocation] = Field(default=None, alias="workingDirectory")
    environment_variables: Optional[Dict[str, StrictStr]] = Field(default=None, description="The environment variables associated with the analysis tool process, expressed as key/value pairs.", alias="environmentVariables")
    stdin: Optional[ArtifactLocation] = None
    stdout: Optional[ArtifactLocation] = None
    stderr: Optional[ArtifactLocation] = None
    stdout_stderr: Optional[ArtifactLocation] = Field(default=None, alias="stdoutStderr")
    properties: Optional[PropertyBag] = None
    __properties: ClassVar[List[str]] = ["commandLine", "arguments", "responseFiles", "startTimeUtc", "endTimeUtc", "exitCode", "ruleConfigurationOverrides", "notificationConfigurationOverrides", "toolExecutionNotifications", "toolConfigurationNotifications", "exitCodeDescription", "exitSignalName", "exitSignalNumber", "processStartFailureMessage", "executionSuccessful", "machine", "account", "processId", "executableLocation", "workingDirectory", "environmentVariables", "stdin", "stdout", "stderr", "stdoutStderr", "properties"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Invocation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in response_files (list)
        _items = []
        if self.response_files:
            for _item in self.response_files:
                if _item:
                    _items.append(_item.to_dict())
            _dict['responseFiles'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in rule_configuration_overrides (list)
        _items = []
        if self.rule_configuration_overrides:
            for _item in self.rule_configuration_overrides:
                if _item:
                    _items.append(_item.to_dict())
            _dict['ruleConfigurationOverrides'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in notification_configuration_overrides (list)
        _items = []
        if self.notification_configuration_overrides:
            for _item in self.notification_configuration_overrides:
                if _item:
                    _items.append(_item.to_dict())
            _dict['notificationConfigurationOverrides'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in tool_execution_notifications (list)
        _items = []
        if self.tool_execution_notifications:
            for _item in self.tool_execution_notifications:
                if _item:
                    _items.append(_item.to_dict())
            _dict['toolExecutionNotifications'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in tool_configuration_notifications (list)
        _items = []
        if self.tool_configuration_notifications:
            for _item in self.tool_configuration_notifications:
                if _item:
                    _items.append(_item.to_dict())
            _dict['toolConfigurationNotifications'] = _items
        # override the default output from pydantic by calling `to_dict()` of executable_location
        if self.executable_location:
            _dict['executableLocation'] = self.executable_location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of working_directory
        if self.working_directory:
            _dict['workingDirectory'] = self.working_directory.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stdin
        if self.stdin:
            _dict['stdin'] = self.stdin.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stdout
        if self.stdout:
            _dict['stdout'] = self.stdout.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stderr
        if self.stderr:
            _dict['stderr'] = self.stderr.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stdout_stderr
        if self.stdout_stderr:
            _dict['stdoutStderr'] = self.stdout_stderr.to_dict()
        # override the default output from pydantic by calling `to_dict()` of properties
        if self.properties:
            _dict['properties'] = self.properties.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Invocation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "commandLine": obj.get("commandLine"),
            "arguments": obj.get("arguments"),
            "responseFiles": [ArtifactLocation.from_dict(_item) for _item in obj["responseFiles"]] if obj.get("responseFiles") is not None else None,
            "startTimeUtc": obj.get("startTimeUtc"),
            "endTimeUtc": obj.get("endTimeUtc"),
            "exitCode": obj.get("exitCode"),
            "ruleConfigurationOverrides": [ConfigurationOverride.from_dict(_item) for _item in obj["ruleConfigurationOverrides"]] if obj.get("ruleConfigurationOverrides") is not None else None,
            "notificationConfigurationOverrides": [ConfigurationOverride.from_dict(_item) for _item in obj["notificationConfigurationOverrides"]] if obj.get("notificationConfigurationOverrides") is not None else None,
            "toolExecutionNotifications": [Notification.from_dict(_item) for _item in obj["toolExecutionNotifications"]] if obj.get("toolExecutionNotifications") is not None else None,
            "toolConfigurationNotifications": [Notification.from_dict(_item) for _item in obj["toolConfigurationNotifications"]] if obj.get("toolConfigurationNotifications") is not None else None,
            "exitCodeDescription": obj.get("exitCodeDescription"),
            "exitSignalName": obj.get("exitSignalName"),
            "exitSignalNumber": obj.get("exitSignalNumber"),
            "processStartFailureMessage": obj.get("processStartFailureMessage"),
            "executionSuccessful": obj.get("executionSuccessful"),
            "machine": obj.get("machine"),
            "account": obj.get("account"),
            "processId": obj.get("processId"),
            "executableLocation": ArtifactLocation.from_dict(obj["executableLocation"]) if obj.get("executableLocation") is not None else None,
            "workingDirectory": ArtifactLocation.from_dict(obj["workingDirectory"]) if obj.get("workingDirectory") is not None else None,
            "environmentVariables": obj.get("environmentVariables"),
            "stdin": ArtifactLocation.from_dict(obj["stdin"]) if obj.get("stdin") is not None else None,
            "stdout": ArtifactLocation.from_dict(obj["stdout"]) if obj.get("stdout") is not None else None,
            "stderr": ArtifactLocation.from_dict(obj["stderr"]) if obj.get("stderr") is not None else None,
            "stdoutStderr": ArtifactLocation.from_dict(obj["stdoutStderr"]) if obj.get("stdoutStderr") is not None else None,
            "properties": PropertyBag.from_dict(obj["properties"]) if obj.get("properties") is not None else None
        })
        return _obj


